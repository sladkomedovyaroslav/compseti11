#include <winsock2.h>
#include <iostream>
#include <vector>
#include <string>
#include <thread>
#include <mutex>

#pragma comment(lib, "ws2_32.lib")

using namespace std;

constexpr int CHAT_PORT = 8888;
constexpr int BUF_LEN = 1024;

vector<SOCKET> sockets;
vector<string> names;
mutex dataMutex;

void Broadcast(const string& text, SOCKET exclude = INVALID_SOCKET)
{
    lock_guard<mutex> lock(dataMutex);
    cout << text << endl;

    for (auto s : sockets)
        if (s != exclude)
            send(s, text.c_str(), text.size(), 0);
}

void SendDirect(SOCKET s, const string& text)
{
    if (s != INVALID_SOCKET)
        send(s, text.c_str(), text.size(), 0);
}

int FindUser(const string& nickname)
{
    lock_guard<mutex> lock(dataMutex);
    for (size_t i = 0; i < names.size(); ++i)
        if (names[i] == nickname)
            return (int)i;
    return -1;
}

void HandleClient(SOCKET client)
{
    char buf[BUF_LEN];
    string nickname = "Guest";

    int len = recv(client, buf, BUF_LEN - 1, 0);
    if (len <= 0) return;

    buf[len] = '\0';
    nickname = buf;

    {
        lock_guard<mutex> lock(dataMutex);
        sockets.push_back(client);
        names.push_back(nickname);
    }

    Broadcast(nickname + " вошёл в чат", client);

    SendDirect(client,
        "Добро пожаловать, " + nickname + "!\n"
        "Команды:\n"
        "/private [ник] [текст]\n"
        "/list\n"
        "/quit\n"
    );

    bool online = true;
    while (online)
    {
        len = recv(client, buf, BUF_LEN - 1, 0);
        if (len <= 0) break;

        buf[len] = '\0';
        string msg = buf;

        if (msg == "/quit")
            break;

        else if (msg == "/list")
        {
            string list = "Пользователи:\n";
            lock_guard<mutex> lock(dataMutex);
            for (auto& n : names)
                list += "- " + n + "\n";
            SendDirect(client, list);
        }

        else if (msg.rfind("/private ", 0) == 0)
        {
            string rest = msg.substr(9);
            size_t pos = rest.find(' ');

            if (pos != string::npos)
            {
                string target = rest.substr(0, pos);
                string text = rest.substr(pos + 1);

                int idx = FindUser(target);
                if (idx != -1)
                {
                    SendDirect(sockets[idx], "Лично от " + nickname + ": " + text);
                    SendDirect(client, "Сообщение отправлено");
                }
                else
                    SendDirect(client, "Пользователь не найден");
            }
        }
        else
        {
            Broadcast(nickname + ": " + msg, client);
        }
    }

    string leaveMsg = nickname + " покинул чат";

    {
        lock_guard<mutex> lock(dataMutex);
        for (size_t i = 0; i < sockets.size(); ++i)
        {
            if (sockets[i] == client)
            {
                closesocket(client);
                sockets.erase(sockets.begin() + i);
                names.erase(names.begin() + i);
                break;
            }
        }
    }

    Broadcast(leaveMsg);
}

int main()
{
    setlocale(LC_ALL, "rus");

    WSADATA wsa;
    WSAStartup(MAKEWORD(2, 2), &wsa);

    SOCKET server = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);

    sockaddr_in addr{};
    addr.sin_family = AF_INET;
    addr.sin_port = htons(CHAT_PORT);
    addr.sin_addr.s_addr = INADDR_ANY;

    bind(server, (sockaddr*)&addr, sizeof(addr));
    listen(server, SOMAXCONN);

    cout << "Чат-сервер запущен. Порт: " << CHAT_PORT << endl;

    while (true)
    {
        sockaddr_in clientAddr{};
        int size = sizeof(clientAddr);
        SOCKET client = accept(server, (sockaddr*)&clientAddr, &size);

        if (client != INVALID_SOCKET)
        {
            cout << "Новое подключение\n";
            thread(HandleClient, client).detach();
        }
    }

    closesocket(server);
    WSACleanup();
    return 0;
}


